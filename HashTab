#include <iostream>
#include "gtest/gtest.h"

typedef std::string Key;

struct Value {
	unsigned age;
	unsigned weight;
};

struct Student {
	Key name;
	Value param;
	Student* next;
};

class HashTable {
public:
	void Free(Student*& stud) {
		if (stud == nullptr) {
			return;
		}
		Free(stud->next);
		delete stud;
	}
	HashTable(): _size(8), _count(0){
		tab = new Student* [_size];
		if (!tab) {
			std::cout << "Error!" << std::endl;
			return;
		}
		for (int i = 0; i < _size; ++i) {
			tab[i] = nullptr;
		}
	}
	~HashTable() {
		for (int i = 0; i < _size; ++i) {
			Free(tab[i]);
		}
		delete[] tab;
	}

	bool CopyStudent(Student*& to, Student*& from) {
		if (!from) {
			return true;
		}
		to = new Student{ from->name, from->param, nullptr };
		if (!to) {
			std::cout << "Error!" << std::endl;
			return false;
		}
		return CopyStudent(to->next, from->next);
	}

	HashTable(const HashTable& b): _size(b._size), _count(b._count){
		tab = new Student * [_size];
		if (!tab) {
			std::cout << "Error!" << std::endl;
		}
		for (int i = 0; i < _size; ++i) {
			tab[i] = nullptr;
		}
		for (int i = 0; i < _size; ++i) {
			CopyStudent(tab[i], b.tab[i]);
		}
	}

	size_t Hash(const Key& k) const{
		size_t res = 0;
		int lim = k.size();
		for (int i = 0; i < lim; ++i) {
			res = (res * 31 + k[i]) % _size;
		}
		return res;
	}

	void swap(HashTable& b);///////////

	HashTable& operator=(const HashTable& b);//////////

	void clear() {
		for (int i = 0; i < _size; ++i) {
			Free(tab[i]);
		}
		delete[] tab;
		tab = new Student * [8];
		_count = 0;
	}

	bool Push(Student*& to, const Key& k, const Value& v) {
		if (!to && to->name != k) {
			Student* stud = new Student{ k, v, nullptr };
			if (!stud) {
				return false;
			}
			to = stud;
			return true;
		}
		else if (Push(to->next, k, v)){
			return true;
		}
		else {
			return false;
		}
	}

	/*bool IncreaseTab(void) {
		Student** newTab = new Student * [_size * 2];
		if (!newTab) {
			return false;
		}
		for()
	}*/

	bool insert(const Key& k, const Value& v) {
		/*if (_count / (double)_size > 1.0) {
			if (!IncreaseTab()) {
				return false;
			}
		}
		else if (_size != 8 && _count / (double)_size < 0.5) {
			if (!DecreaseTab()) {
				return false;
			}
		}*/
		size_t i = Hash(k);
		if (Push(tab[i], k, v)) {
			++_count;
			return true;
		}
		return false;
	}

	bool FindAndErase(Student*& stud, const Key& k) {
		if (!stud) {
			return false;
		}
		else if (stud->name != k) {
			return FindAndErase(stud->next, k);
		}
		else {
			Student* next = stud->next;
			free(stud);
			stud = next;
			return true;
		}
	}

	bool erase(const Key& k) {
		size_t i = Hash(k);
		if (!FindAndErase(tab[i], k)) {
			return false;
		}
		--_count;
		return true;
	}

	bool Find(Student*& stud, const Key& k) const {
		if (!stud) {
			return false;
		}
		else if (stud->name != k) {
			return Find(stud->next, k);
		}
		else {
			return true;
		}
	}

	bool contains(const Key& k) const {
		size_t i = Hash(k);
		if (!Find(tab[i], k)) {
			return false;
		}
		return true;
	}

	Value& Get(Student*& stud, const Key& k) const{
		if (stud && stud->name == k) {
			return stud->param;
		}
		else if(stud){
			return Get(stud->next, k);
		}
	}

	Value& operator[](const Key& k) {
		size_t i = Hash(k);
		return Get(tab[i], k);
	}

	Value& at(const Key& k) {
		size_t i = Hash(k);
		return Get(tab[i], k);
	}
	const Value& at(const Key& k) const {
		size_t i = Hash(k);
		return Get(tab[i], k);
	}

	size_t size() const {
		return _size;
	}
	bool empty() const {
		if (!_count) {
			return false;
		}
		return true;
	}

	friend bool operator==(const HashTable& a, const HashTable& b);////////////////
	friend bool operator!=(const HashTable& a, const HashTable& b);/////////////////

private:
	size_t _size;
	size_t _count;
	Student **tab;
};

int main()
{
	HashTable A;
	std::cout << A.size() << std::endl;
	return 0;
}

